<div class="container" id="i18_about_servirtium">
    <div class="row m-b-lg">
        <div class="col-lg-12 text-center">
            <div class="navy-line"></div>
            <h1><span data-i18n="about_servirtium.about_servirtium">Servirtium - Service Virtualization for tests</span></h1>
            <p>For Agile & CI/CD & DevOps loving teams</p>
        <img src="https://raw.githubusercontent.com/servirtium/README/master/Servirtium-Square.png">
        </div>
    </div>
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 text-left m-t-lg m-b-lg wow zoomIn">
            <p><span data-i18n="about_servirtium.des">Servirtium is a markdown syntax for recorded and played back HTTP conversations coupled to automated test scenarios. It has libraries available for many languages</span></p>
            <h1><a id="user-content-who-would-use-servirtium" class="anchor" aria-hidden="true" href="#who-would-use-servirtium"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Who would use Servirtium?</h1>
            <ul>
                <li>Developers and test engineers wanting to write fast automated tests that would invoke slow or flaky remote services over HTTP</li>
                <li>Enlightened vendors and service makers wanting to ship executable know-how to their clients and developer community</li>
                <li>People that super love Markdown in Git, and look for excuses to lol around in that stuff</li>
                <li>Coders that have JSON fatigue or don't like "test data" (or similar) in a a shared service/database</li>
            </ul>
            <h1><a id="user-content-what-is-servirtium" class="anchor" aria-hidden="true" href="#what-is-servirtium"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> What is Servirtium?</h1>
            <p>Servirtium aims to be <strong>a lingua franca for mock HTTP conversations using Markdown under source-control</strong>:</p>
            <ul>
                <li>with interoperable record and playback capability in Java, C#, Ruby, Python, NodeJS, Go, Rust and more.</li>
                <li>for test-automation purposes only</li>
                <li>API makers should get on board too, shipping markdown conversations for known test scenarios (as well as a sample test that would use that in their fave language)</li>
                <li>oh, and JSON/YAML is the <strong>wrong</strong> format for encoding HTTP conversations in - it is not pretty on the eye and not easily eyeball diffable</li>
            </ul>
            <h2><a id="user-content-in-common-with-other-service-virtualization-technologies" class="anchor" aria-hidden="true" href="#in-common-with-other-service-virtualization-technologies"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> In common with other "Service Virtualization" technologies</h2>
            <ul>
                <li>tests can leverage previously recorded HTTP conversations:</li>
                <li>are much faster than real services which can vary in speed at least, but are typically slower than desired</li>
                <li>don't fail in unexpected ways - real services can be flaky</li>
                <li>don't require credentials per person running the tests - real services often require API keys/tokens (even "sandbox" ones) and devs often share those against vendor (and employer) rules.</li>
            </ul>
            <h2><a id="user-content-the-markdown-difference" class="anchor" aria-hidden="true" href="#the-markdown-difference"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> The markdown difference</h2>
            <p>With Servirtium, the HTTP conversations for services invoked by running tests
                would be recorded and played back from the same Markdown format. Multiple language implementations would be able work with the same Markdown
                standard, and it would be possible to record a HTTP conversation with (say) a Ruby library using Test::Unit and the play them back via a
                (say) Java library for JUnit/TestNG test-writing teams. That would be for the situation where the Ruby team was publishing an API and
                bundled unit tests with it, but the team consuming API was in a different org/department and was using Java instead of Ruby.</p>
            <p>So this would be exclusively for test automation purposes. Production deployments would not use any Servirtium technologies - the <strong>real</strong> services would be hooked
                up there.</p>
            <h2><a id="user-content-related-contract-ideastools" class="anchor" aria-hidden="true" href="#related-contract-ideastools"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Related contract ideas/tools.</h2>
            <p><a href="https://raml.org/" rel="nofollow">RAML</a> and <a href="https://swagger.io/" rel="nofollow">Swagger</a> are complimentary specification technologies, not competitive.</p>
            <h1><a id="user-content-example-of-the-servirtium-markdown-format" class="anchor" aria-hidden="true" href="#example-of-the-servirtium-markdown-format"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Example of the Servirtium Markdown format</h1>
            <p>Here's a screen-shot of some raw markdown source:</p>
            <p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/82182/67832718-7092e380-fada-11e9-94a8-58dcc82810cb.png"><img src="https://user-images.githubusercontent.com/82182/67832718-7092e380-fada-11e9-94a8-58dcc82810cb.png" alt="2019-10-30_0559" style="max-width:100%;"></a></p>
            <p>(non-screenshot actual source: <a href="https://raw.githubusercontent.com/servirtium/README/master/example1.md" rel="nofollow">https://raw.githubusercontent.com/servirtium/README/master/example1.md</a>)</p>
            <p>Here's what GitHub (for one) renders that like:</p>
            <p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/82182/67832562-f2ced800-fad9-11e9-9bbf-8a366ad7c938.png"><img src="https://user-images.githubusercontent.com/82182/67832562-f2ced800-fad9-11e9-9bbf-8a366ad7c938.png" alt="2019-10-30_0555" style="max-width:100%;"></a></p>
            <p>That's the whole point of this format that's human-inspectable in raw form and that your code-portal renders in a pretty way too.
                If your code portal is GitHub, then 'pretty' is true.</p>
            <p>(non-screenshot actual rendered file: <a href="https://github.com/servirtium/README/blob/master/example1.md">https://github.com/servirtium/README/blob/master/example1.md</a>)</p>
            <p>... and you'd be storing that VCS as you would your automated tests.</p>
            <h2><a id="user-content-markdown-syntax-explained" class="anchor" aria-hidden="true" href="#markdown-syntax-explained"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Markdown Syntax Explained</h2>
            <h3><a id="user-content-multiple-interactions-catered-for" class="anchor" aria-hidden="true" href="#multiple-interactions-catered-for"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Multiple Interactions Catered For</h3>
            <p>Each interaction is denoted via a <strong>Level 2 Markdown Heading</strong>. e.g. <code>## Interaction N: &lt;METHOD&gt; &lt;PATH-FROM-ROOT&gt;</code></p>
            <p><code>N</code> starts as 0, and goes up depending on how many interactions there were in the conversation.</p>
            <p><code>&lt;METHOD&gt;</code> is GET or POST (or any standard HTML or non standard method/verb name).</p>
            <p><code>&lt;PATH-FROM-ROOT&gt;</code> is the path without the domain &amp; port. e.g. /card/addTo.doIt</p>
            <h3><a id="user-content-request-and-reply-details-per-interaction" class="anchor" aria-hidden="true" href="#request-and-reply-details-per-interaction"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Request And Reply Details Per Interaction</h3>
            <p>Each interaction has four sections denoted by a *<em>Level 3 Markdown headers</em></p>
            <ol>
                <li>The request headers going from the client to the HTTP server, denoted with a heading like so <code>### Request headers recorded for playback:</code></li>
                <li>The request body going from the client to the HTTP server (if applicable - GET does not use this), denoted  with a heading like so <code>### Request body recorded for playback (&lt;MIME-TYPE&gt;):</code>. And <code>&lt;MIME-TYPE&gt;</code> is something like <code>application/json</code></li>
                <li>The response headers coming back from the HTTP server to the client, denoted with a heading like so <code>### Response headers recorded for playback:</code></li>
                <li>The response body coming back from the HTTP server to the client (some HTTP methods do not use this), denoted with a heading like so <code>### Response body recorded for playback (&lt;STATUS-CODE&gt;: &lt;MIME-TYPE&gt;):</code></li>
            </ol>
            <p>Within each of those there is a single Markdown code block (three back-ticks) with the details of each.  The lines in that
                block may be reformatted depending on the settings of the recorder. If binary, then there is a Base64
                sequence instead (admittedly not so pretty on the eye).</p>
            <h1><a id="user-content-discussing-recording-and-playback" class="anchor" aria-hidden="true" href="#discussing-recording-and-playback"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Discussing Recording and Playback</h1>
            <h2><a id="user-content-recording-a-http-conversation" class="anchor" aria-hidden="true" href="#recording-a-http-conversation"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Recording a HTTP conversation</h2>
            <p>You'll write your test (say JUnit) and that will use a library (that your company may have written or be from a vendor). For
                recording you will swap the real service URL for one running a Servirtium middle-man server (which itself will delegate to
                the real service).  If that service is flaky - keep re-running the test manually until the service is non-flaky, and commit
                that Servirtium-style markdown to source-control.  Best practice is to configure the same test two have two modes of
                operation: 'direct' and 'recording' modes.</p>
            <p>Anyway, the recording ends up in the markdown described in a text file on your file system - which you'll commit to
                VCS alongside your tests.</p>
            <h2><a id="user-content-playback-of-http-conversations" class="anchor" aria-hidden="true" href="#playback-of-http-conversations"><svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a> Playback of HTTP conversations</h2>
            <p>Those same markdown recordings are used in playback.</p>
            <p>Playback itself will fail if the headers/body <strong>sent by the client to the real service</strong> (through the Servirtium library)
                are <strong>not</strong> the same they were when the recording was made. It is possible that masking/redacting and general manipulations should happen
                deliberately during the recording to get rid of transient aspects that are not helpful in playback situations.  The test
                failing in this situation is deliberate - you're using this to guard against potential incompatibilities.</p>
            <p>For example any dates in headers of the body that go from the client to the HTTP Server could be swapped for some date
                in the future like "2099-01-01" or a date in the past "1970-01-01".</p>
            <p>The person who's designing the tests
                that recording or playback would work on the redactions/masking towards an "always passing" outcome, with no differences
                in the markdown regardless of the number of time the same test is re-recorded.</p>
            <p>Note: How a difference in request-header or request-body expectation is
                logged in the test output needs to be part of the deliberate design of the tests themselves. This is easier said than
                done, and you can't catch assertion failures over HTTP.</p>
            <p>Note2: this is a third mode of operation for the same test as in "Recording a HTTP conversation" above - "playback"
                mode meaning you have three modes of operation all in all.</p>
        </div>
    </div>
</div>
